<!DOCTYPE html>
<html lang="ro">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Nea Ion cel mai TOP — Pixel Galaxy (Univers dinamic + Warp)</title>
<style>
  :root{
    --c1:#00ffff; --c2:#ff66cc; --c3:#ffcc00; --c4:#00ff66;
    --panel:#13141a; --panel-border:#2ee7ff; --text:#f8f8ff;
  }

  /* ===== Bază: canvas pe tot ecranul (univers) ===== */
  html,body{
    margin:0; padding:0; height:100vh; width:100vw; overflow:hidden;
    background:#02030a; /* backup dacă canvas nu pornește */
    font-family:'Courier New', monospace; color:var(--text);
  }
  #universe{
    position:fixed; inset:0; z-index:-10; display:block; background: radial-gradient(1200px 800px at 50% 120%, #050a16 0%, #02030a 60%, #000 100%);
  }

  /* Un mic “glow” deasupra canvas-ului, foarte subtil, pentru profunzime */
  .sky-glow{
    position:fixed; inset:0; z-index:-9; pointer-events:none;
    background:
      radial-gradient(800px 600px at 20% 30%, rgba(124,58,237,.10), transparent 60%),
      radial-gradient(1000px 800px at 80% 70%, rgba(14,165,233,.08), transparent 65%),
      radial-gradient(1200px 900px at 50% -10%, rgba(255,105,180,.06), transparent 70%);
    mix-blend-mode:screen;
    animation: skyDrift 80s linear infinite;
  }
  @keyframes skyDrift{
    0%{transform:translate(0,0) scale(1)}
    50%{transform:translate(-40px,30px) scale(1.04)}
    100%{transform:translate(0,0) scale(1)}
  }

  /* ===== Titlu neon care ricoșează ===== */
  .center-text{
    position:absolute; left:100px; top:100px; z-index:3;
    font-weight:900; font-size:clamp(2rem,6vw,4.2rem); line-height:1;
    background:linear-gradient(270deg,var(--c2),var(--c1),var(--c3),var(--c4),var(--c2));
    background-size:600% 600%;
    -webkit-background-clip:text; background-clip:text; -webkit-text-fill-color:transparent;
    text-shadow:0 0 12px rgba(255,255,255,.25), 0 0 40px rgba(0,255,255,.12);
    animation:gradientFlow 10s ease infinite, pulse 2.2s ease-in-out infinite;
    cursor:pointer; user-select:none;
  }
  @keyframes gradientFlow{0%{background-position:0 50%}50%{background-position:100% 50%}100%{background-position:0 50%}}
  @keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.08) rotate(1.2deg)}}

  /* ===== Panouri / butoane / HUD ===== */
  .panel{
    background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
    backdrop-filter: blur(6px);
    border:4px solid var(--panel-border);
    box-shadow:0 0 0 8px rgba(139,92,246,.25), inset 0 0 0 2px rgba(255,255,255,.06),
               0 18px 40px rgba(0,0,0,.6), 0 0 24px rgba(46,231,255,.25);
    border-radius:14px;
  }
  .pixel-border{ position:relative; }
  .pixel-border:before{ content:""; position:absolute; inset:-6px; border:2px solid rgba(255,255,255,.15);
    filter:drop-shadow(0 0 6px rgba(46,231,255,.4)); border-radius:6px; pointer-events:none; }
  .btn{
    background:linear-gradient(45deg,var(--c2),var(--c3)); color:#0b0b13; font-weight:700; border:none;
    padding:10px 16px; border-radius:10px; cursor:pointer;
    box-shadow:0 4px 0 #000, 0 0 12px rgba(255,102,204,.6);
    transition:transform .08s ease, filter .2s ease;
  }
  .btn:active{ transform:translateY(2px); box-shadow:0 2px 0 #000, 0 0 6px rgba(255,102,204,.6) }

  .hud{ position:fixed; top:12px; left:12px; z-index:5; padding:10px 14px; font-weight:800; }
  .hud small{opacity:.8}

  .modal{ position:fixed; inset:0; display:none; z-index:6; justify-content:center; align-items:center; background:rgba(0,0,0,.65); }
  .modal .content{ width:min(760px,92vw); padding:22px; text-align:center; }

  .game{ position:fixed; inset:0; display:none; z-index:7; justify-content:center; align-items:center; gap:16px; background:rgba(0,0,0,.6); }
  .stage{ position:relative; width:min(900px, 92vw); height:min(60vh, 520px); overflow:hidden; padding:16px; }
  #gameCat,#gameDog{
    position:absolute; text-align:center; user-select:none; cursor:pointer; transform:translate(-50%,-50%);
    filter:drop-shadow(0 4px 10px rgba(0,0,0,.6)) drop-shadow(0 0 16px rgba(255,255,255,.3));
  }
  #gameCat{ --size:96px; width:var(--size); height:var(--size); line-height:var(--size); font-size:calc(var(--size)*.66); }
  #gameDog{ width:84px; height:84px; line-height:84px; font-size:56px; opacity:.95; }

  /* Scanlines ușoare */
  .scanlines{ position:fixed; inset:0; z-index:10; pointer-events:none;
    background:
      radial-gradient(ellipse at 50% 50%, rgba(0,0,0,0) 60%, rgba(0,0,0,.45) 100%),
      repeating-linear-gradient(to bottom, rgba(255,255,255,.03) 0 2px, transparent 2px 4px);
    mix-blend-mode:screen;
  }

  /* Efecte mici */
  .ripple{ position:fixed; width:12px; height:12px; border-radius:50%; border:2px solid rgba(255,255,255,.45);
           pointer-events:none; z-index:2; transform:translate(-50%,-50%); animation:ripple .6s ease-out forwards; }
  @keyframes ripple{ from{opacity:.8; transform:translate(-50%,-50%) scale(.4)} to{opacity:0; transform:translate(-50%,-50%) scale(8)} }
  .flash{ animation: flash .18s ease; }
  @keyframes flash{ from{filter:brightness(1.4)} to{filter:brightness(1)} }
</style>
</head>
<body>

  <!-- CANVAS UNIVERS (noul super-fundal) -->
  <canvas id="universe"></canvas>
  <div class="sky-glow"></div>

  <!-- Titlu ricoșeu -->
  <div class="center-text" id="title" title="Deschide meniul">🎉 Nea Ion cel mai TOP 🎉</div>

  <!-- HUD (joc) -->
  <div class="hud panel pixel-border" id="hud" style="display:none;">
    <div><span>🐱 Scor:</span> <span id="score">0</span></div>
    <div><small>⚡ Viteză:</small> <span id="speedLabel">1.0x</span></div>
    <div><small>🧭 Nivel:</small> <span id="levelLabel">1</span></div>
    <div><small>⏳ Timp:</small> <span id="timeLabel">30.0s</span></div>
  </div>

  <!-- MODAL principal -->
  <div class="modal" id="modal1" role="dialog" aria-modal="true">
    <div class="content panel pixel-border">
      <h2 style="margin:8px 0 6px">Ia uite-l pe Nea Ion 🕺</h2>
      <p style="margin:0 0 14px; opacity:.85">Universul s-a pregătit special pentru Ion. Dă-i drumul la distracție!</p>
      <div style="margin:10px auto 18px; display:flex; flex-direction:column; align-items:center; gap:10px;">
        <div style="font-size:1.2rem; font-weight:900; letter-spacing:.5px;">Eu sunt Ion, cel mai tare dansator</div>
        <img src="https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExNnRzM25yZjl6cWVzOTRqNmd5aWJzcjVweGR0N3Nwem1jendzaGI1dCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/BK1EfIsdkKZMY/giphy.gif"
             alt="Ion dansează" style="max-width:100%; width:360px; border-radius:12px; box-shadow:0 12px 30px rgba(0,0,0,.5); outline:3px solid var(--panel-border);"/>
      </div>
      <div style="display:flex; gap:12px; justify-content:center; flex-wrap:wrap;">
        <button class="btn" onclick="openGame()">Joacă ‘Prinde Pisica’ 🐱</button>
        <button class="btn" onclick="openModal('controls')">Controale fundal 🌌</button>
        <button class="btn" onclick="closeModal('modal1')">Închide ✖</button>
      </div>
      <p style="margin-top:10px; opacity:.7; font-size:.9rem;">
        Trucuri Univers: Ține apăsat <b>W</b> = warp 🌀 • Ține apăsat <b>C</b> = constelații ✨ • Mișcă mouse-ul pentru parallax.
      </p>
    </div>
  </div>

  <!-- MODAL: Controale fundal -->
  <div class="modal" id="controls" role="dialog" aria-modal="true">
    <div class="content panel pixel-border">
      <h3 style="margin:8px 0 10px;">Controale pentru UNIVERS 🌌</h3>
      <div style="text-align:left; margin:0 auto; max-width:560px; line-height:1.6;">
        <ul style="margin:0; padding-left:18px;">
          <li><b>W</b> (ține apăsat): Hyper-Warp (zbor printre stele)</li>
          <li><b>C</b> (ține apăsat): Conexiuni de constelație</li>
          <li><b>S</b>: Activează/dezactivează stelele căzătoare</li>
          <li><b>+</b>/<b>-</b>: Mai multe/mai puține stele</li>
          <li><b>R</b>: Reset univers (re-generează stelele)</li>
          <li><b>Click</b>: Undă/ripple și scântei</li>
        </ul>
      </div>
      <div style="margin-top:14px; display:flex; gap:12px; justify-content:center; flex-wrap:wrap;">
        <button class="btn" onclick="toggleShooters()">Stele căzătoare ON/OFF 🌠</button>
        <button class="btn" onclick="regenUniverse()">Re-generează stelele ♻️</button>
        <button class="btn" onclick="closeModal('controls')">Închide ✖</button>
      </div>
    </div>
  </div>

  <!-- Joc -->
  <div class="game" id="game" aria-live="polite">
    <div class="content panel pixel-border" style="text-align:center;">
      <h2 style="margin:6px 0 14px">Prinde Pisica 🐱 (+ Câine șiret 🐶)</h2>
      <div class="stage panel pixel-border" id="stage" aria-label="Arena de joc">
        <div id="gameCat" title="Prinde-mă!">🐱</div>
        <div id="gameDog" title="Nu da click pe mine!" style="display:none;">🐶</div>
      </div>
      <div style="margin-top:12px; display:flex; gap:10px; justify-content:center; flex-wrap:wrap;">
        <button class="btn" onclick="resetGame()">Restart 🔁</button>
        <button class="btn" onclick="exitGame()">Ieșire ✖</button>
      </div>
    </div>
  </div>

  <div class="scanlines"></div>

<script>
/* ============================================================
   UNIVERS CANVAS: stele 3D, warp, constelații, parallax, meteoriți
   ============================================================ */
(() => {
  const canvas = document.getElementById('universe');
  const ctx = canvas.getContext('2d');

  let W = canvas.width = window.innerWidth;
  let H = canvas.height = window.innerHeight;
  let CX = W/2, CY = H/2;

  // Parametri
  let starCount = Math.min(1200, Math.floor(W*H/1400)); // densitate în funcție de ecran
  let fov = 400;          // focala pentru proiecție
  let baseSpeed = 0.8;    // viteză bază spre camera (z-)
  let warp = 1;           // factor warp (crește când ții W)
  let warpTarget = 1;     // easing spre țintă
  let constellations = false;
  let shootersEnabled = true;

  const stars = [];
  const maxZ = 1200;
  const minZ = 60;

  const mouse = {x: CX, y: CY};

  function rndSign(){ return Math.random() < 0.5 ? -1 : 1; }
  function rand(a,b){ return Math.random()*(b-a)+a; }

  function makeStar(){
    return {
      x: rand(-W, W),
      y: rand(-H, H),
      z: rand(minZ, maxZ),
      px: 0, py: 0, // pentru trail
      hue: rand(180, 320), // culori reci/violete
      tw: rand(0.5, 1.5)   // twinkle factor
    };
  }

  function init(){
    stars.length = 0;
    for(let i=0;i<starCount;i++) stars.push(makeStar());
  }

  function resize(){
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    CX = W/2; CY = H/2;
    starCount = Math.min(1200, Math.floor(W*H/1400));
    init();
  }
  window.addEventListener('resize', resize);

  // Warp & constelații pe taste
  const keys = new Set();
  window.addEventListener('keydown', (e)=>{
    keys.add(e.key.toLowerCase());
    if(e.key==='+'){ starCount = Math.min(2000, starCount+100); regenUniverse(); }
    if(e.key==='-'){ starCount = Math.max(200, starCount-100); regenUniverse(); }
    if(e.key.toLowerCase()==='r') regenUniverse();
    if(e.key.toLowerCase()==='s') toggleShooters();
  });
  window.addEventListener('keyup', (e)=> keys.delete(e.key.toLowerCase()));

  canvas.addEventListener('mousemove', (e)=>{ mouse.x = e.clientX; mouse.y = e.clientY; });
  window.addEventListener('click', (e)=> ripple(e.clientX, e.clientY));

  function ripple(x,y){
    const r=document.createElement('div');
    r.className='ripple'; r.style.left=x+'px'; r.style.top=y+'px';
    document.body.appendChild(r); setTimeout(()=>r.remove(),650);
  }

  function regenUniverse(){
    init();
  }
  window.regenUniverse = regenUniverse;
  window.toggleShooters = ()=>{ shootersEnabled = !shootersEnabled; };

  // Meteoriți (stele căzătoare)
  function shootingStar(){
    if(!shootersEnabled) return;
    const len = rand(120, 240);
    const x0 = rand(0, W*0.8);
    const y0 = rand(-40, H*0.3);
    ctx.save();
    ctx.translate(x0, y0);
    ctx.rotate(rand(15,35) * Math.PI/180);
    const grad = ctx.createLinearGradient(0,0, len,0);
    grad.addColorStop(0, 'rgba(255,255,255,0.9)');
    grad.addColorStop(1, 'rgba(255,255,255,0.0)');
    // desenăm în 3 frame-uri pentru "blink"
    let t = 0;
    function tail(){
      t++;
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,len,2);
      if(t<3) requestAnimationFrame(tail);
      else ctx.restore();
    }
    tail();
  }
  setInterval(()=>{ if(Math.random()<0.4) shootingStar(); }, 1800);

  function project(star){
    const scale = fov / (star.z);
    return {
      x: star.x * scale + CX,
      y: star.y * scale + CY,
      s: (1.2 - star.z/maxZ) * 2.2  // mărimea aparentă
    };
  }

  function update(dt){
    // Warp țintă
    warpTarget = keys.has('w') ? 5 : 1; // ține W pentru hyper-warp
    warp += (warpTarget - warp) * Math.min(1, dt*4);

    // constelații
    constellations = keys.has('c');

    // mișcare stele
    const v = baseSpeed * warp * (1 + 0.5*Math.sin(performance.now()*0.001)); // mic puls
    for(const s of stars){
      s.z -= v*60*dt;
      if(s.z < minZ){ // re-spawn în depărtare
        s.z = maxZ;
        s.x = rand(-W, W);
        s.y = rand(-H, H);
        s.px = 0; s.py = 0;
      }
    }
  }

  function draw(dt){
    // fade subtil pentru a păstra urme (motion blur ușor)
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = 'rgba(2,3,10,0.4)';
    ctx.fillRect(0,0,W,H);

    ctx.globalCompositeOperation = 'lighter';

    // Proiectăm o dată pozițiile ecran pentru linie constelație
    const screenPts = [];
    for(const s of stars){
      const p = project(s);
      screenPts.push(p);
    }

    // Conexiuni constelație: near mouse + între vecini apropiați
    if(constellations){
      const maxDist = 120;
      ctx.lineWidth = 0.7;
      ctx.strokeStyle = 'rgba(173,216,255,0.25)';
      ctx.beginPath();
      for(let i=0;i<screenPts.length;i++){
        const a = screenPts[i];
        // prioritar conectăm stelele apropiate de mouse
        const dMouse = Math.hypot(a.x - mouse.x, a.y - mouse.y);
        if(dMouse < 180){
          for(let j=i+1;j<i+10 && j<screenPts.length;j++){
            const b = screenPts[j];
            const d = Math.hypot(a.x-b.x, a.y-b.y);
            if(d < maxDist){
              ctx.moveTo(a.x, a.y);
              ctx.lineTo(b.x, b.y);
            }
          }
        }
      }
      ctx.stroke();
    }

    // Desenăm stelele + trails
    for(let i=0;i<stars.length;i++){
      const s = stars[i];
      const p = screenPts[i];

      // Twinkle
      const tw = 0.7 + 0.3*Math.sin((performance.now()*0.005) + s.tw);

      // Trail (linie din poziția precedentă pe ecran)
      if(s.px && s.py){
        ctx.strokeStyle = `hsla(${s.hue},100%,70%,${0.25*warp})`;
        ctx.lineWidth = Math.max(0.5, p.s*0.35);
        ctx.beginPath();
        ctx.moveTo(s.px, s.py);
        ctx.lineTo(p.x, p.y);
        ctx.stroke();
      }
      s.px = p.x; s.py = p.y;

      // Punctul
      const r = Math.max(0.6, p.s*tw);
      ctx.fillStyle = `hsla(${s.hue},100%,${60 + (1-p.s)*20}%,${0.9})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI*2);
      ctx.fill();
    }

    // indicator mic warp în colț
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    ctx.font = 'bold 12px Courier New, monospace';
    ctx.fillText(`Warp: ${warp.toFixed(1)}x  |  Stele: ${starCount}`, 12, H-12);
  }

  let last = performance.now();
  function loop(){
    const now = performance.now();
    const dt = Math.min(0.05, (now - last)/1000);
    last = now;
    update(dt);
    draw(dt);
    requestAnimationFrame(loop);
  }

  init();
  loop();
})();

/* ============================================================
   Titlu care ricoșează + modale + joc (minim, neschimbat)
   ============================================================ */
const title = document.getElementById('title');
let tx=120, ty=120, dx=2.0, dy=1.6;
(function animateTitle(){
  const rect=title.getBoundingClientRect(); const w=innerWidth, h=innerHeight; let hit=false;
  if(tx+rect.width>=w || tx<=10){ dx*=-1; hit=true; ripple(tx+rect.width/2, ty+rect.height/2); }
  if(ty+rect.height>=h || ty<=10){ dy*=-1; hit=true; ripple(tx+rect.width/2, ty+rect.height/2); }
  tx+=dx; ty+=dy; title.style.left=tx+"px"; title.style.top=ty+"px";
  requestAnimationFrame(animateTitle);
  if(hit) shuffleTheme();
})();

function ripple(x,y){
  const r=document.createElement('div');
  r.className='ripple'; r.style.left=x+'px'; r.style.top=y+'px';
  document.body.appendChild(r); setTimeout(()=>r.remove(),650);
}

function shuffleTheme(){
  const root=document.documentElement;
  const cols = [getVar('--c1'),getVar('--c2'),getVar('--c3'),getVar('--c4')];
  cols.push(cols.shift());
  root.style.setProperty('--c1', cols[0]);
  root.style.setProperty('--c2', cols[1]);
  root.style.setProperty('--c3', cols[2]);
  root.style.setProperty('--c4', cols[3]);
}
function getVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

title.onclick = ()=> openModal('modal1');

/* ===== Modale ===== */
function openModal(id){ document.getElementById(id).style.display='flex'; }
function closeModal(id){ document.getElementById(id).style.display='none'; }
addEventListener('click', e=>{ if(e.target.classList.contains('modal')) closeModal(e.target.id); });

/* ===== Joc rapid (aceeași logică prinde pisica + câine) ===== */
const gameEl=document.getElementById('game');
const stage=document.getElementById('stage');
const cat=document.getElementById('gameCat');
const dog=document.getElementById('gameDog');
const hud=document.getElementById('hud');
const scoreEl=document.getElementById('score');
const speedEl=document.getElementById('speedLabel');
const levelEl=document.getElementById('levelLabel');
const timeEl=document.getElementById('timeLabel');

let score=0, level=1, target=10;
let timeLeft=30, size=96;
let baseInterval=1400, interval=baseInterval, speed=1;
let moveTimer=null, tickRAF=null;
const rafMap=new WeakMap();
let dogActive=false;

function openGame(){ closeModal('modal1'); closeModal('controls'); gameEl.style.display='flex'; hud.style.display='block'; resetGame(); }
function exitGame(){
  gameEl.style.display='none'; hud.style.display='none';
  clearTimeout(moveTimer); cancelAnimationFrame(tickRAF);
  const idC=rafMap.get(cat); if(idC) cancelAnimationFrame(idC);
  const idD=rafMap.get(dog); if(idD) cancelAnimationFrame(idD);
}
function resetGame(){
  score=0; level=1; target=10; timeLeft=30; size=96; baseInterval=1400; interval=baseInterval; speed=1;
  dogActive=false; dog.style.display='none';
  cat.style.setProperty('--size', size+'px');
  centerEl(cat); centerEl(dog);
  updateHUD(); clearTimeout(moveTimer); cancelAnimationFrame(tickRAF);
  scheduleMove(); startTimer();
}
function updateHUD(){ scoreEl.textContent=score; speedEl.textContent=(1400/interval).toFixed(1)+'x'; levelEl.textContent=level; timeEl.textContent=timeLeft.toFixed(1)+'s'; }

function scheduleMove(){
  clearTimeout(moveTimer);
  moveTimer=setTimeout(()=>{
    moveElSmooth(cat, interval);
    if(dogActive && Math.random()<0.8) moveElSmooth(dog, interval*rand(0.85,1.35), rand(-60,60));
    scheduleMove();
  }, interval);
}
function rand(a,b){ return Math.random()*(b-a)+a; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

function centerEl(el){ const r=stage.getBoundingClientRect(); setElPos(el, r.width/2, r.height/2); }
function setElPos(el,x,y){ x=clamp(x,48,stage.clientWidth-48); y=clamp(y,48,stage.clientHeight-48); el.style.left=x+'px'; el.style.top=y+'px'; }
function moveElSmooth(el, intervalHint=interval, jitter=0){
  const start={x:parseFloat(el.style.left||"0"), y:parseFloat(el.style.top||"0")};
  let tx=rand(48,stage.clientWidth-48)+jitter, ty=rand(48,stage.clientHeight-48)+jitter;
  tx=clamp(tx,48,stage.clientWidth-48); ty=clamp(ty,48,stage.clientHeight-48);
  const duration=Math.max(240, Math.min(900, intervalHint*0.6));
  const t0=performance.now();
  function step(){
    const t=performance.now(); const p=Math.min(1,(t-t0)/duration);
    const e=p<0.5?2*p*p:-1+(4-2*p)*p;
    setElPos(el, start.x+(tx-start.x)*e, start.y+(ty-start.y)*e);
    if(p<1){ const id=requestAnimationFrame(step); rafMap.set(el,id); }
  }
  const id=requestAnimationFrame(step); rafMap.set(el,id);
}

cat.addEventListener('click',(e)=>{
  score++;
  if(interval>260) interval=Math.max(260, interval-60);
  if(score>=target){
    level++; target+=8+Math.floor(level*1.2); size=Math.max(64,size-6);
    cat.style.setProperty('--size', size+'px'); timeLeft+=4;
    popup(`NIVEL ${level} 🔥`, innerWidth/2, 80);
  }
  if(!dogActive){
    dogActive=true; dog.style.display='block'; centerEl(dog);
    moveElSmooth(dog, interval*1.1, rand(-40,40));
  }
  const r=cat.getBoundingClientRect();
  burst(r.left+r.width/2, r.top+r.height/2);
  cat.classList.add('flash'); setTimeout(()=>cat.classList.remove('flash'),180);
  moveElSmooth(cat, interval); scheduleMove(); updateHUD(); e.stopPropagation();
});

dog.addEventListener('click',(e)=>{
  const r=dog.getBoundingClientRect(), cx=r.left+r.width/2, cy=r.top+r.height/2;
  score=Math.max(0, score-2); timeLeft=Math.max(0, timeLeft-2);
  popup('-2', cx, cy-20); burst(cx,cy,'#ff3355'); dog.classList.add('flash'); setTimeout(()=>dog.classList.remove('flash'),180);
  moveElSmooth(dog, interval*0.9, rand(-40,40)); updateHUD(); e.stopPropagation();
});

function startTimer(){
  let last=performance.now();
  function tick(){
    const now=performance.now(); const dt=(now-last)/1000; last=now;
    timeLeft-=dt;
    if(timeLeft<=0){ popup('GAME OVER 💥', innerWidth/2, 100); exitGame(); return; }
    updateHUD(); tickRAF=requestAnimationFrame(tick);
  }
  tickRAF=requestAnimationFrame(tick);
}

stage.addEventListener('click',(e)=>{
  const r=stage.getBoundingClientRect(); setElPos(cat, e.clientX-r.left, e.clientY-r.top);
});

/* ===== Efecte generice ===== */
function burst(x,y,color='#ffffff'){
  const ctx = document.getElementById('universe').getContext('2d');
  ctx.save();
  ctx.globalCompositeOperation='lighter';
  for(let i=0;i<16;i++){
    const ang = Math.random()*Math.PI*2, dist = Math.random()*40+20;
    ctx.strokeStyle = color==='#{random}' ? `hsla(${Math.random()*360},100%,70%,.8)` : color;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + Math.cos(ang)*dist, y + Math.sin(ang)*dist);
    ctx.stroke();
  }
  ctx.restore();
}
function popup(text,x,y){
  const el=document.createElement('div');
  el.textContent=text; el.style.position='fixed'; el.style.left=(x-6)+'px'; el.style.top=(y-12)+'px';
  el.style.fontWeight='900'; el.style.textShadow='0 0 8px rgba(255,255,255,.6)'; el.style.zIndex=8; el.style.pointerEvents='none';
  el.animate([{transform:'translateY(0)',opacity:1},{transform:'translateY(-40px)',opacity:0}],{duration:650,easing:'ease-out'});
  document.body.appendChild(el); setTimeout(()=>el.remove(),660);
}

/* ===== Helper pentru stele (burst pe click pe canvas) ===== */
document.getElementById('universe').addEventListener('click', (e)=> burst(e.clientX, e.clientY, '#a0d8ff'));

</script>
</body>
</html>
